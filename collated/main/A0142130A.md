# A0142130A
###### \java\seedu\taskell\commons\events\storage\StorageLocationChangedEvent.java
``` java
package seedu.taskell.commons.events.storage;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.events.BaseEvent;

/**
 * Indicates storage location has changed.
 */
public class StorageLocationChangedEvent extends BaseEvent {
    
    private Config config;
    
    public StorageLocationChangedEvent(Config config) {
        this.config = config;
    }
    
    public Config getConfig() {
        return config;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\ClearCommandInputEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** indicates ClearCommand is being executed
 * */

public class ClearCommandInputEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayCalendarViewEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates display panel needs to show calendar **/

public class DisplayCalendarViewEvent extends BaseEvent {
   
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayListChangedEvent.java
``` java
package seedu.taskell.commons.events.ui;

import java.util.ArrayList;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a list needs to be displayed on Display Panel
 * */
public class DisplayListChangedEvent extends BaseEvent {
    
    private ArrayList<String> list;
    
    public DisplayListChangedEvent(ArrayList<String> list) {
        this.list = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public ArrayList<String> getList() {
        return list;
    }

}
```
###### \java\seedu\taskell\commons\events\undo\ExecutedIncorrectCommandEvent.java
``` java
package seedu.taskell.commons.events.undo;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a Command has been entered incorrectly, to feedback to History
 *  NOTE: this is different from IncorrectCommandAttemptedEvent (which is meant for UI)
 */

public class ExecutedIncorrectCommandEvent extends BaseEvent {
    
    private boolean isUndoableCommand;
    
    public ExecutedIncorrectCommandEvent(boolean isUndoableCommand) {
        this.isUndoableCommand = isUndoableCommand;
    }
    
    public boolean isUndoableCommand() {
        return isUndoableCommand;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\taskell\logic\commands\ClearCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.ClearCommandInputEvent;
import seedu.taskell.model.TaskManager;

/**
 * Clears the task manager. Will show confirm dialog before clearing.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Clear command executed.";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Clears all tasks.\n"
            + "Example: " + COMMAND_WORD;
    
    private static ClearCommand self;
    private static boolean isUnderTesting;  //for testing ONLY

    public ClearCommand() {}

    public static ClearCommand getInstance() {
        if (self == null) {
            self = new ClearCommand();
        }
        
        return self;
    }
    
    /** if set to true, ClearCommand bypasses confirm dialog
     *  for running test cases ONLY
     * */
    public static void setIsUnderTesting(boolean value) {
        isUnderTesting = value;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        if (isUnderTesting) {
            executeClear();
        } else {
            raiseClearCommandInputEvent();
        }
        
        return new CommandResult(MESSAGE_SUCCESS);
    }
    
    /** executes reset data
     *  will be called from UiManager after confirmation of clear
     * */
    public void executeClear() {
        model.resetData(TaskManager.getEmptyTaskManager());
    }

    private void raiseClearCommandInputEvent() {
        EventsCenter.getInstance().post(new ClearCommandInputEvent());      
    }
    
}
```
###### \java\seedu\taskell\logic\commands\FindCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description and tags contains all of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contains all of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " milk bananas chicken";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\taskell\logic\commands\FindTagCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "find-tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contain any of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " help study homework";

    private final Set<String> keywords;

    public FindTagCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByAnyKeyword(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\commands\IncorrectCommand.java
``` java
    
    /** for setting latest command as an undoable command
     * */
    public static void setIsUndoableCommand(boolean value) {
        isAddEditDeleteCommand = value;
    }
    
    public static boolean isUndoableCommand() {
        return isAddEditDeleteCommand;
    }
    
    /** if latest command is an undoable command, need to delete its command history
     * */
    private void indicateExecutedIncorrectCommand() {
        EventsCenter.getInstance().post(new ExecutedIncorrectCommandEvent(isAddEditDeleteCommand));
    }

```
###### \java\seedu\taskell\logic\commands\SaveStorageLocationCommand.java
``` java
package seedu.taskell.logic.commands;

import java.io.IOException;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.storage.StorageLocationChangedEvent;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.storage.JsonConfigStorage;
import seedu.taskell.storage.Storage;

/** Saves current data file to new filepath.
 * */

public class SaveStorageLocationCommand extends Command {
    
    private Logger logger = LogsCenter.getLogger(SaveStorageLocationCommand.class.getName());
    
    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data file to new location specified. "
            + "New files can be auto-created as long as given directory is valid.\n"
            + "Parameters: FILEPATH (must be valid)\n"
            + "Example: " + COMMAND_WORD + " C:\\Users\\chicken\\Desktop\\cat";
    
    private static final String MESSAGE_SUCCESS = "Data successfully saved to new location.";
    private static final String MESSAGE_INVALID_PATH = "Filepath given is invalid. Filepath will be reset to old path.";
    
    private static Config config;
    private String newStorageFilePath, oldStorageFilePath;
    private ReadOnlyTaskManager taskManager;
    private static JsonConfigStorage jsonConfigStorage;
    private static Storage storage;
    
    public SaveStorageLocationCommand(String newStorageFilePath) {
        this.oldStorageFilePath = config.getTaskManagerFilePath();
        logger.info("Old file path: " + oldStorageFilePath);
        
        this.newStorageFilePath = newStorageFilePath.trim().replace("\\", "/") + "/taskmanager.xml";
        logger.info("New file path: " + this.newStorageFilePath);
        jsonConfigStorage = new JsonConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }
    
    public static void setConfig(Config c) {
        config = c;
    }
    
    public static void setStorage(Storage s) {
        storage = s;
    }

    @Override
    public CommandResult execute() {
        assert config != null;
        assert jsonConfigStorage != null;

        taskManager = model.getTaskManager();
        
        config.setTaskManagerFilePath(newStorageFilePath);
        indicateStorageLocationChanged();
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        
        saveToConfigJson();
        model.updateFilteredListToShowAll();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    private void indicateStorageLocationChanged() {
        assert config != null;
        EventsCenter.getInstance().post(new StorageLocationChangedEvent(config));
    }
    
    private void handleInvalidFilePathException() {
        logger.info("Error writing to filepath. Handling data save exception.");
        assert config != null;
        
        config.setTaskManagerFilePath(oldStorageFilePath);  //set back to old filepath
        indicateStorageLocationChanged();
        
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            logger.severe("Error saving task manager");
        }
        
        saveToConfigJson();
    }
    
    private void saveToConfigJson() {
        try {
            jsonConfigStorage.saveConfigFile(config);
        } catch (IOException e) {
            logger.severe("save to config json error");
        }
    }

}
```
###### \java\seedu\taskell\logic\commands\UndoCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.ArrayList;
import java.util.logging.Logger;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.model.CommandHistory;
import seedu.taskell.model.History;
import seedu.taskell.model.HistoryManager;
import seedu.taskell.model.Model;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.taskell.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Undo previously executed commands (add, delete, edit)
 * Note: only for current session only (meaning after app is closed, history will be cleared)
 */
public class UndoCommand extends Command {
    private static final Logger logger = LogsCenter.getLogger(UndoCommand.class.getName());
    
    public static final String COMMAND_WORD = "undo";
    public static final String EDIT = "edit";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo a previously executed command.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 3";
    
    private static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private static final String MESSAGE_ADD_TASK_SUCCESS = "Task added back: %1$s";
    private static final String MESSAGE_EDIT_TASK_SUCCESS = "Task edited back to old version: %1$s";
    
    private static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";
    private static final String MESSAGE_NO_TASK_TO_UNDO = "No add or delete commands available to undo.";
    private static final String MESSAGE_COMMAND_HISTORY_EMPTY = "No command history available for undo.";
    private static final String MESSAGE_INVALID_INDEX = "Index is invalid";
    
    private ArrayList<CommandHistory> commandHistoryList;
    private History history;
    
    private int index;
    private CommandHistory commandHistory;
    
    public UndoCommand(int index) {
        logger.info("Creating UndoCommand with index: " + index);
        
        history = HistoryManager.getInstance();
        commandHistoryList = history.getList();
        this.index = index;
    }

    public UndoCommand() {
        logger.info("Creating UndoCommand without index");
        
        history = HistoryManager.getInstance();
        commandHistoryList = history.getList();
        this.index = commandHistoryList.size(); //offset will be done in execute()
    }

    @Override
    public CommandResult execute() {
        
        if (commandHistoryList.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_COMMAND_HISTORY_EMPTY));
        } else if (index > commandHistoryList.size()) {
            return new CommandResult(String.format(MESSAGE_INVALID_INDEX));
        }
        
        commandHistory = commandHistoryList.get(getOffset(index));
        
        if (commandHistory.isRedoTrue()) {
            return redoUndo();
        }
        
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return undoAdd();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return undoDelete();
        } else if (commandType.contains(EDIT)) {
            return undoEdit();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
        
    }

    private CommandResult redoUndo() {
        
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return undoDelete();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return undoAdd();
        } else if (commandType.contains(EDIT)) {
            return redoEdit();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
        
    }

    private CommandResult undoEdit() {
        try {
            model.editTask(commandHistory.getTask(), commandHistory.getOldTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getOldTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Undo edit should return a command result";
        return null;
    }
    
    private CommandResult redoEdit() {
        try {
            model.editTask(commandHistory.getOldTask(), commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Redo edit should return a command result";
        return null;
    }

    private CommandResult undoDelete() {
        try {
            model.addTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_ADD_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

    private CommandResult undoAdd() {
        try {
            model.deleteTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, commandHistory.getTask()));
    }
    
    private void addUndoCommand(CommandHistory commandHistory) {
        if (commandHistory.isRedoTrue()) {
            return;
        }
        commandHistory.setCommandText("undo " + commandHistory.getCommandText());
        commandHistory.setToRedoToTrue();
        commandHistoryList.add(commandHistory);
    }
    
    /******** static methods *********/
    
    private static int getOffset(int index) {
        return index - 1;
    }

    /****** Event ******/
    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }
}
```
###### \java\seedu\taskell\logic\commands\ViewCalendarCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayCalendarViewEvent;

/** Shows calendar view on right panel
 * */
public class ViewCalendarCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "calendar";
    public static final String COMMAND_WORD_2 = "cal";
    
    public static final String MESSAGE_SUCCESS = "Displayed calendar.";

    @Override
    public CommandResult execute() {
        indicateDisplayCalendarView();
        return new CommandResult(String.format(MESSAGE_SUCCESS));
    }
    
    private void indicateDisplayCalendarView() {
        EventsCenter.getInstance().post(new DisplayCalendarViewEvent());
    }

}
```
###### \java\seedu\taskell\logic\commands\ViewHistoryCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.model.History;
import seedu.taskell.model.HistoryManager;

/** Lists a list of previous commands available for Undo operation
 * */
public class ViewHistoryCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "history";
    public static final String COMMAND_WORD_2 = "hist";

    public static final String MESSAGE_SUCCESS = "Listed all commands available for undo.";
    
    private static ViewHistoryCommand self;
    private History history;
    
    public ViewHistoryCommand() {
        history = HistoryManager.getInstance();
    }
    
    public static ViewHistoryCommand getInstance() {
        if (self == null) {
            self = new ViewHistoryCommand();
        }
        
        return self;
    }

    @Override
    public CommandResult execute() {
        indicateDisplayListChanged();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }

}
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java
    
    private Command prepareClear(String arguments) {
        if (arguments.isEmpty()) {
            return new ClearCommand();
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        }
        
    }
    
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * if type of command is undoable, saves to history for undoing
     */
    private void saveToHistory(String userInput, final String commandWord) {
        if (commandWord.equals(AddCommand.COMMAND_WORD) || commandWord.equals(DeleteCommand.COMMAND_WORD)
                || commandWord.contains(UndoCommand.EDIT)) {
            IncorrectCommand.setIsUndoableCommand(true);
            history.addCommand(userInput, commandWord);
        } else {
            IncorrectCommand.setIsUndoableCommand(false);
        }
    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * Parses arguments in the context of undo command.
     * 
     */
    private Command prepareUndo(String args) {
        if (args.isEmpty()) {
            return new UndoCommand();
        }

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
        return new UndoCommand(index.get());
    }

    /**
     * Parses arguments in the context of the find task by tags command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindByTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindTagCommand(keywordSet);

    }

    /**
     * Parses arguments in the context of the save storage location command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSaveStorageLocation(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveStorageLocationCommand.MESSAGE_USAGE));
        }
        return new SaveStorageLocationCommand(args);
    }
```
###### \java\seedu\taskell\MainApp.java
``` java
    @Subscribe
    private void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
        config = event.getConfig();
        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
    }
```
###### \java\seedu\taskell\model\CommandHistory.java
``` java
package seedu.taskell.model;

import seedu.taskell.model.task.Task;

/** Stores the relevant details of a command so it can be undone via UndoCommand
 *  each Add/Delete/Edit Command executed should correspond to a CommandHistory 
 *  stored in UndoCommand's list of CommandHistory
 * */
public class CommandHistory {
    private String commandText, commandType;
    private Task task;      //relevent task to be added, deleted or edited
    private Task oldTask;   //oldTask needed for EditCommands
    private boolean isRedoCommand;
    
    public CommandHistory() {
        commandText = "default command text";
        commandType = "default command type";
        task = null;
        isRedoCommand = false;
    }
    
    public CommandHistory(String commandText, String commandType) {
        assert commandText != null;
        assert commandType != null;
        assert !commandText.trim().isEmpty();
        assert !commandType.trim().isEmpty();
        
        this.commandText = commandText.trim();
        this.commandType = commandType.trim();
        this.task = null;
        isRedoCommand = false;
    }
    
    public String getCommandText() {
        return commandText;
    }
    
    public String getCommandType() {
        return commandType;
    }
    
    public Task getTask() {
        return task;
    }
    
    public Task getOldTask() {
        return oldTask;
    }
    
    public boolean isRedoTrue() {
        return isRedoCommand;
    }
    
    /**** Setter methods ****/
    
    public void setCommandText(String text) {
        this.commandText = text;
    }
    
    public void setTask(Task task) {
        assert task != null;
        this.task = task;
        if (commandType.equals("delete")) {
            commandText = "delete " + this.task.getAsText();
        }
    }
    
    public void setOldTask(Task task) {
        this.oldTask = task;
    }
    
    public void setToRedoToTrue() {
        isRedoCommand = true;
    }
    
}
```
###### \java\seedu\taskell\model\History.java
``` java
package seedu.taskell.model;

import java.util.ArrayList;

import seedu.taskell.model.task.Task;

/** API of History, holds command history available for undo
 */
public interface History {
    
    /** Returns list of command history */
    ArrayList<CommandHistory> getList();
    
    /** Returns list of command history text form*/
    ArrayList<String> getListCommandText();
    
    /** Clears internal history */
    void clear();
    
    /** Adds new command to history */
    void addCommand(String commandText, String commandType);
    
    /** Updates most recent command history with the relevant Task created */
    void addTask(Task task);
    
    /** Updates most recent command history with the relevant old Task (for edit commands only)*/
    void addOldTask(Task task);
    
    /** Checks if task is present in internal model */
    boolean isTaskPresent(Task task);
    
    /** Most recent command is incorrect, needs to be deleted */
    void deleteLatestCommand();

    /** Deletes a given CommandHistory */
    void deleteCommandHistory(CommandHistory commandHistory);

    /** removes Tasks no longer in system (i.e. manually deleted/cleared) */
    void updateList();
    
}
```
###### \java\seedu\taskell\model\HistoryManager.java
``` java
package seedu.taskell.model;

import java.util.ArrayList;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.undo.ExecutedIncorrectCommandEvent;
import seedu.taskell.logic.commands.AddCommand;
import seedu.taskell.model.task.Task;

/** Implementation of History API, manages command history available for undo
 */
public class HistoryManager implements History {

    private static final Logger logger = LogsCenter.getLogger(HistoryManager.class.getName());
    private static final String EDIT = "edit";
    
    private static ArrayList<CommandHistory> historyList;
    private static Model model;
    private static HistoryManager self;
    
    public HistoryManager() {
        historyList = new ArrayList<>();
    }
    
    public static History getInstance() {
        if (self == null) {
            self = new HistoryManager();
        }    
        return self;
    }
    
    public static void setModel(Model m) {
        model = m;
    }
    
    @Override
    public ArrayList<CommandHistory> getList() {
        return historyList;
    }

    @Override
    /** returns list of command history's user input strings
     * */
    public ArrayList<String> getListCommandText() {
        assert historyList != null;
        
        updateList();
        
        ArrayList<String> list = new ArrayList<>();
        for (CommandHistory history: historyList) {
            list.add(history.getCommandText());
        }
        
        return list;
    }
    
    @Override
    /** should be called whenever DeleteCommand is executed
     *  deletes history of the task deleted
     * */
    public synchronized void updateList() {
        if (model == null) {
            logger.severe("Model is null");
            return;
        }
        
        for (CommandHistory commandHistory: historyList) {
            if (isCommandTypeAddOrEdit(commandHistory) 
                    && !isTaskPresent(commandHistory.getTask())) {
                historyList.remove(commandHistory);
            } else if (isUndoEditCommand(commandHistory) 
                    && !isTaskPresent(commandHistory.getTask())) {
                historyList.remove(commandHistory);
            }
        }
    }
    
    private boolean isCommandTypeAddOrEdit(CommandHistory commandHistory) {
        return (commandHistory.getCommandType().contains(AddCommand.COMMAND_WORD) 
                || commandHistory.getCommandType().contains(EDIT)) 
                && !commandHistory.isRedoTrue();
    }
    
    private boolean isUndoEditCommand(CommandHistory commandHistory) {
        return commandHistory.isRedoTrue() 
                && commandHistory.getCommandType().contains(EDIT);
    }

    @Override
    public void clear() {
        logger.info("Clearing history...");
        historyList.clear();        
    }

    @Override
    public void addCommand(String commandText, String commandType) {
        assert historyList != null;
        historyList.add(new CommandHistory(commandText, commandType));
    }

    @Override
    public void addTask(Task task) {
        logger.info("Adding task to history");
        if (historyList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        historyList.get(getOffset(historyList.size())).setTask(task);
    }

    @Override
    public void addOldTask(Task task) {
        logger.info("Adding old task to history");
        if (historyList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        historyList.get(getOffset(historyList.size())).setOldTask(task);
    }

    @Override
    public boolean isTaskPresent(Task task) {
        return model.isTaskPresent(task);
    }
    
    @Override
    public void deleteLatestCommand() {
        logger.info("Command unsuccessfully executed. Deleting command history.");
        if (historyList.isEmpty()) {
            logger.warning("No command history to delete");
            return;
        }
        historyList.remove(getOffset(historyList.size()));
    }

    @Override
    public void deleteCommandHistory(CommandHistory commandHistory) {
        historyList.remove(commandHistory);
    }
    
    private static int getOffset(int index) {
        return index - 1;
    }

    @Subscribe
    private void handleExecuteIncorrectCommandEvent(ExecutedIncorrectCommandEvent event) {
        if (event.isUndoableCommand()) {
            deleteLatestCommand();
        }
    }

    
}
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByAnyKeyword(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new TagsQualifier(keywords)));
    }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getDescription().description + " " + task.tagsSimpleString();
            return nameKeyWords.stream().allMatch(keyword -> StringUtil.containsIgnoreCase(searchString, keyword));
        }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    private class TagsQualifier implements Qualifier {
        private Set<String> tagsKeyWords;

        TagsQualifier(Set<String> keyWords) {
            this.tagsKeyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagsKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.tagsSimpleString(), keyword)).findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagsKeyWords);
        }
    }

```
###### \java\seedu\taskell\storage\JsonConfigStorage.java
``` java
package seedu.taskell.storage;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.commons.util.FileUtil;

/**
 * A class to access Config stored in the hard disk as a json file
 */

public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);
    
    private String filePath;
    
    public JsonConfigStorage(String filePath) {
        this.filePath = filePath;
    }
    
    @Override
    public Optional<Config> readConfigFile() throws DataConversionException, IOException {
        return readConfig(filePath);
    }

    @Override
    public void saveConfigFile(Config config) throws IOException {
        saveConfig(config, filePath);
    }
    
    /**
     * Similar to {@link #readConfigFile()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readConfig(String configFilePath) throws DataConversionException {
        assert configFilePath != null;

        File configFile = new File(configFilePath);

        if (!configFile.exists()) {
            logger.info("Config file "  + configFile + " not found");
            return Optional.empty();
        }

        Config config;

        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + configFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(config);
    }

    /**
     * Similar to {@link #saveConfigFile(Config)}
     * @param configFilePath location of the data. Cannot be null.
     */
    private void saveConfig(Config config, String configFilePath) throws IOException {
        assert config != null;
        assert configFilePath != null;
        assert !configFilePath.isEmpty();

        FileUtil.serializeObjectToJsonFile(new File(configFilePath), config);
    }

}
```
###### \java\seedu\taskell\ui\CalendarView.java
``` java
package seedu.taskell.ui;

import java.time.LocalDateTime;
import java.util.ArrayList;

import jfxtras.scene.control.agenda.Agenda;
import jfxtras.scene.control.agenda.Agenda.Appointment;
import seedu.taskell.model.Model;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.model.task.ReadOnlyTask;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.TaskStatus;
import seedu.taskell.model.task.UniqueTaskList;

/** This class holds the necessary elements to display calendar UI via Agenda API from jfxtras
 * */

public class CalendarView {
    
    private static Model model;
    
    private Agenda agenda;
    
    public CalendarView() {
        agenda = new Agenda();
        setAgendaProperties();
        loadTasks();
    }
    
    public static void setData(Model m) {
        model = m;
    }
    
    public Agenda getAgenda() {
        agenda.appointments().clear();
        loadTasks();
        return agenda;
    }
    
    private void setAgendaProperties() {
        agenda.setAllowDragging(false);
        agenda.setAllowResize(false);
        agenda.setFocusTraversable(false);
        
        agenda.setStyle("-fx-font-size: 12pt");
    }
    
    public void loadTasks() {
        agenda.appointments().clear();
        
        ReadOnlyTaskManager taskManager = model.getTaskManager();
        UniqueTaskList taskList = taskManager.getUniqueTaskList();
        
        ArrayList<Appointment> appointments = new ArrayList<>();
        int i=1;
        
        for (ReadOnlyTask task: taskList) {
            
            if (isValidEventTask(task)) {
                appointments.add(new Agenda.AppointmentImplLocal()
                        .withStartLocalDateTime(task.getStartDate().toLocalDateTime(task.getStartTime()))
                        .withEndLocalDateTime(task.getEndDate().toLocalDateTime(task.getEndTime()))
                        .withSummary(task.getDescription().description)
                        .withAppointmentGroup(
                                new Agenda.AppointmentGroupImpl().withStyleClass("group"+i)));
            }
            
            i++;
        }
        
        agenda.appointments().addAll(appointments);
        
        //"-fx-background-color: #EC407A; -fx-fill: #EC407A;"
    }

    private boolean isValidEventTask(ReadOnlyTask task) {
        return task.getTaskStatus().toString().equals(TaskStatus.INCOMPLETE) 
                && task.getTaskType().equals(Task.EVENT_TASK);
    }

}
```
###### \java\seedu\taskell\ui\DisplayPanel.java
``` java
package seedu.taskell.ui;

import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import jfxtras.scene.control.agenda.Agenda;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.util.FxViewUtil;
import seedu.taskell.logic.commands.AddCommand;
import seedu.taskell.logic.commands.HelpCommand;
import seedu.taskell.logic.commands.ViewCalendarCommand;
import seedu.taskell.logic.commands.ViewHistoryCommand;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * The Display Panel of the App, on right side of screen
 * shows history or calendar view
 * calendar view is default view
 */
public class DisplayPanel extends UiPart {

    public static final String MESSAGE_NO_HISTORY = "No commands available for undo.";
    public static final String MESSAGE_DISPLAY_HISTORY = "List of command history available for undo:\n";

    private static final String WELCOME_MESSAGE = "Welcome to Taskell!\n"
            + "Enter '" + AddCommand.COMMAND_WORD + "' in command box to add a task.\n"
            + "Enter '" + ViewHistoryCommand.COMMAND_WORD_1 + "' for a list of commands to undo.\n"
            + "Enter '" + ViewCalendarCommand.COMMAND_WORD_1 + "' to view calendar.\n"
            + "Enter '" + HelpCommand.COMMAND_WORD + "' for more information about commands.";

    private static Logger logger = LogsCenter.getLogger(DisplayPanel.class);
    
    public static final String DISPLAY_PANEL_ID = "displayPanel";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    
    private TextArea displayTextArea;
    private CalendarView calendarView;
    private Agenda agenda;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a DisplayPanel.
     */
    private DisplayPanel() {
        calendarView = new CalendarView();
        displayTextArea = new TextArea();
        agenda = calendarView.getAgenda();
    }

    @Override
    public void setNode(Node node) {
        //not applicable
    }

    @Override
    public String getFxmlPath() {
        return null; //not applicable
    }

    /**
     * This method should be called after the FX runtime is initialized and in FX application thread.
     * @param placeholder The AnchorPane where the DisplayPanel must be inserted
     */
    public static DisplayPanel load(AnchorPane placeholder){
        logger.info("Initializing displayTextArea panel");
        DisplayPanel displayPanel = new DisplayPanel();
        
        displayPanel.displayTextArea.setEditable(false);
        displayPanel.displayTextArea.setId(DISPLAY_PANEL_ID);
        displayPanel.displayTextArea.getStyleClass().removeAll();
        displayPanel.displayTextArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        
        FxViewUtil.applyAnchorBoundaryParameters(displayPanel.displayTextArea, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(displayPanel.displayTextArea);
        
        displayPanel.displayTextArea.setText(WELCOME_MESSAGE);
       
        return displayPanel;
    }
    
    /** called whenever history list needs to be shown on display panel
     * */
    public void loadList(AnchorPane placeholder, ArrayList<String> list) {
        placeholder.getChildren().clear();
        placeholder.getChildren().add(displayTextArea);
        
        displayTextArea.setText("");
        if (list.isEmpty()) {
            displayTextArea.setText(MESSAGE_NO_HISTORY);
        }
        else {
            displayTextArea.setText(MESSAGE_DISPLAY_HISTORY);
            for (int i=0; i<list.size(); i++) {
                int index = i+1;
                displayTextArea.appendText(index + ". " + list.get(i) + "\n");
            }
        }
    }
    
    /** default view
     *  clears panel if displayTextArea is showing
     *  fills panel with Agenda for events for the week
     * */
    public void loadCalendar(AnchorPane placeholder) {

        placeholder.getChildren().clear();
        agenda = calendarView.getAgenda();
        FxViewUtil.applyAnchorBoundaryParameters(agenda, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(agenda);
             
    }
    
```
###### \java\seedu\taskell\ui\MainWindow.java
``` java
    
    public void loadList(ArrayList<String> list) {
        displayPanel.loadList(displayPanelPlaceholder, list);
    }
    
    public void loadCalendarView() {
        displayPanel.loadCalendar(displayPanelPlaceholder);
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    private Alert showConfirmClearAlertDialogAndWait() {
        return showAlertDialogAndWaitForConfirm(Alert.AlertType.CONFIRMATION, "Clear all tasks?", 
                "Clear all tasks?", "Are you sure you wish to clear all data?");
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    @Subscribe
    private void handleDisplayList(DisplayListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying list...");
        mainWindow.loadList(event.getList());
    }
    
    @Subscribe
    private void handleShowCalendarView(DisplayCalendarViewEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying calendar view...");
        mainWindow.loadCalendarView();
    }
    
    @Subscribe
    private void handleClearCommandInput(ClearCommandInputEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        Alert alert = showConfirmClearAlertDialogAndWait();
        
        if (alert.getResult() == ButtonType.OK) {
            logger.info("clearing");
            ClearCommand.getInstance().executeClear();
        }
    }
    
```
