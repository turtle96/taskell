# A0139257X
###### \java\seedu\taskell\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: DESCRIPTION by/on[DATE] from[START_TIME] to[END_TIME] [p/PRIORITY] [r/daily] [#TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " go for meeting on 1-1-2100 from 12.30AM to 12.45AM p/3 r/daily #work";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskType, String[] taskComponentArray, boolean[] hasTaskComponentArray, Set<String> tags) throws IllegalValueException {
        
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        switch (taskType) {
        case Task.FLOATING_TASK: 
            this.toAdd = new FloatingTask(taskComponentArray, hasTaskComponentArray, new UniqueTagList(tagSet));
            break;
        case Task.EVENT_TASK:
            this.toAdd = new EventTask(taskComponentArray, hasTaskComponentArray, new UniqueTagList(tagSet));
            break;
        default:
            toAdd = null;
        }
    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param full
     *            command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        ArrayList<String> argsList = tokenizeArguments(args);
        Queue<String> initialQueue = initialiseArgQueue(argsList);

        initialisePartitionQueue();
        initialiseHasTaskComponentArray();
        initialiseTaskComponentArray();

        try {
            splitInputIntoComponents(initialQueue);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        addReservedWordToDescription(); // Add trailing reserved word to
                                        // description

        extractDescriptionComponent();
        adjustStartTime();

        return addTaskAccordingToType();
    }

    /**
     * Returns a new AddCommand object according to task type if successful else
     * return IncorrectCommand
     */
    private Command addTaskAccordingToType() {
        if (isEventTask()) {
            try {
                return new AddCommand(Task.EVENT_TASK, taskComponentArray, hasTaskComponentArray,
                        getTagsFromArgs(taskComponentArray[Task.TAG]));
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        } else {
            try {
                return new AddCommand(Task.FLOATING_TASK, taskComponentArray, hasTaskComponentArray,
                        getTagsFromArgs(taskComponentArray[Task.TAG]));
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }
    }

    /**
     * Separates the content in the initialQueue into its different task
     * components
     * 
     * @throws IllegalValueException
     */
    private void splitInputIntoComponents(Queue<String> initialQueue) throws IllegalValueException {
        String token = "";
        int priorityCount = 0;
        int recurrenceCount = 0;

        while (!initialQueue.isEmpty()) {
            token = initialQueue.poll().trim();
            if (!isReservedWord(token)) {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
                continue;
            } else if (token.equals(BY)) {
                offerTokenToQueue(BY_QUEUE, token);
                continue;
            } else if (token.equals(ON)) {
                offerTokenToQueue(ON_QUEUE, token);
                continue;
            } else if (token.equals(AT)) {
                offerTokenToQueue(AT_QUEUE, token);
                continue;
            } else if (token.equals(FROM)) {
                offerTokenToQueue(FROM_QUEUE, token);
                continue;
            } else if (token.equals(TO)) {
                offerTokenToQueue(TO_QUEUE, token);
                continue;
            } else if (token.startsWith(Tag.PREFIX)) {
                addReservedWordToDescription();
                taskComponentArray[Task.TAG] += " " + token;
                continue;
            } else if (token.startsWith(TaskPriority.PREFIX)) {
                addReservedWordToDescription();
                if (priorityCount > 0) {
                    throw new IllegalValueException(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                } else {
                    taskComponentArray[Task.TASK_PRIORITY] = token.substring(token.indexOf(TaskPriority.PREFIX) + 2);
                    priorityCount++;
                }
                continue;
            } else if (token.startsWith(RecurringType.PREFIX)) {
                addReservedWordToDescription();
                if (recurrenceCount > 0) {
                    throw new IllegalValueException(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                } else {
                    taskComponentArray[Task.RECURRING_TYPE] = token.substring(token.indexOf(RecurringType.PREFIX) + 2);
                    hasTaskComponentArray[Task.RECURRING_COMPONENT] = true;
                    recurrenceCount++;
                }
            } else if (TaskDate.isValidDate(token)) {
                determineDateisActualDateOrDescription(token);
            } else if (TaskTime.isValidTime(token)) {
                determineTimeIsActualTimeOrDescription(token);
            }
        }
    }

    /**
     * Determine if the given token is an intended date or is part of a
     * description Token is actual date if it is preceded by a Date-Time prefix
     */
    private void determineDateisActualDateOrDescription(String token) {
        if (!isPrecededByDateTimePrefix(partitionQueue)) {
            partitionQueue.get(DESCRIPTION_QUEUE).offer(token);
        } else if (isPrecededByPrefixInQueue(ON_QUEUE)) {
            if (!hasTaskComponentArray[Task.START_DATE_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, ON_QUEUE, Task.START_DATE, Task.START_DATE_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(BY_QUEUE)) {
            if (!hasTaskComponentArray[Task.END_DATE_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, BY_QUEUE, Task.END_DATE, Task.END_DATE_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(AT_QUEUE)) {
            addReservedWordToDescription();
            partitionQueue.get(DESCRIPTION_QUEUE).offer(token);
        } else if (isPrecededByPrefixInQueue(FROM_QUEUE)) {
            if (!hasTaskComponentArray[Task.START_DATE_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, FROM_QUEUE, Task.START_DATE, Task.START_DATE_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(TO_QUEUE)) {
            if (!hasTaskComponentArray[Task.END_DATE_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, TO_QUEUE, Task.END_DATE, Task.END_DATE_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        }
    }

    /**
     * Determine if the given token is an intended time or is part of a
     * description Token is actual time if it is preceded by a Date-Time prefix
     */
    private void determineTimeIsActualTimeOrDescription(String token) {
        if (!isPrecededByDateTimePrefix(partitionQueue)) {
            partitionQueue.get(DESCRIPTION_QUEUE).offer(token);
        } else if (isPrecededByPrefixInQueue(BY_QUEUE)) {
            if (!hasTaskComponentArray[Task.END_TIME_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, BY_QUEUE, Task.END_TIME, Task.END_TIME_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(AT_QUEUE)) {
            if (!hasTaskComponentArray[Task.START_TIME_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, AT_QUEUE, Task.START_TIME, Task.START_TIME_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(FROM_QUEUE)) {
            if (!hasTaskComponentArray[Task.START_TIME_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, FROM_QUEUE, Task.START_TIME, Task.START_TIME_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(TO_QUEUE)) {
            if (!hasTaskComponentArray[Task.END_TIME_COMPONENT]) {
                extractDateTimeWhenPrecededByPrefix(token, TO_QUEUE, Task.END_TIME, Task.END_TIME_COMPONENT);
            } else {
                offerTokenToQueue(DESCRIPTION_QUEUE, token);
            }
        } else if (isPrecededByPrefixInQueue(ON_QUEUE)) {
            offerTokenToQueue(DESCRIPTION_QUEUE, token);
        }
    }

    /**
     * Flush outstanding Date-Time prefix into description queue Add Token to
     * respective queue
     */
    private void offerTokenToQueue(int queueType, String token) {
        addReservedWordToDescription();
        partitionQueue.get(queueType).offer(token);
    }

    private boolean isEventTask() {
        return hasTaskComponentArray[Task.START_DATE_COMPONENT] || hasTaskComponentArray[Task.END_DATE_COMPONENT]
                || hasTaskComponentArray[Task.START_TIME_COMPONENT] || hasTaskComponentArray[Task.END_TIME_COMPONENT];
    }

    private void adjustStartTime() {
        if ((TaskDate.isValidToday(taskComponentArray[Task.START_DATE])
                && !hasTaskComponentArray[Task.START_TIME_COMPONENT])
                || taskComponentArray[Task.START_DATE].equals(TaskDate.DEFAULT_DATE)
                        && !hasTaskComponentArray[Task.START_TIME_COMPONENT]) {

            taskComponentArray[Task.START_TIME] = TaskTime.getTimeNow().toString();
        }
    }

    private void extractDescriptionComponent() {
        while (!partitionQueue.get(DESCRIPTION_QUEUE).isEmpty()) {
            taskComponentArray[Task.DESCRIPTION] += partitionQueue.get(DESCRIPTION_QUEUE).poll() + " ";
        }
        taskComponentArray[Task.DESCRIPTION].trim();
    }

    private void extractDateTimeWhenPrecededByPrefix(String token, int queueType, int taskComponent,
            int taskComponentBoolean) {
        partitionQueue.get(queueType).poll();
        taskComponentArray[taskComponent] = token;
        hasTaskComponentArray[taskComponentBoolean] = true;
    }

    private boolean isPrecededByDateTimePrefix(ArrayList<Queue<String>> partitionQueue) {
        return !partitionQueue.get(BY_QUEUE).isEmpty() || !partitionQueue.get(ON_QUEUE).isEmpty()
                || !partitionQueue.get(AT_QUEUE).isEmpty() || !partitionQueue.get(FROM_QUEUE).isEmpty()
                || !partitionQueue.get(TO_QUEUE).isEmpty();
    }

    private boolean isPrecededByPrefixInQueue(int queueType) {
        return !partitionQueue.get(queueType).isEmpty();
    }

    private boolean isReservedWord(String token) {
        return token.equals(BY) || token.equals(ON) || token.equals(AT) || token.equals(FROM) || token.equals(TO)
                || TaskDate.isValidDate(token) || TaskTime.isValidTime(token) || token.startsWith(Tag.PREFIX)
                || token.startsWith(TaskPriority.PREFIX) || token.startsWith(RecurringType.PREFIX);
    }

    private void addReservedWordToDescription() {
        String tempToken = flushQueue(partitionQueue);
        if (!tempToken.isEmpty()) {
            partitionQueue.get(DESCRIPTION_QUEUE).offer(tempToken);
        }
    }

    private String flushQueue(ArrayList<Queue<String>> partitionQueue) {
        String token = "";

        if (!partitionQueue.get(BY_QUEUE).isEmpty()) {
            token = partitionQueue.get(BY_QUEUE).poll();
        } else if (!partitionQueue.get(ON_QUEUE).isEmpty()) {
            token = partitionQueue.get(ON_QUEUE).poll();
        } else if (!partitionQueue.get(AT_QUEUE).isEmpty()) {
            token = partitionQueue.get(AT_QUEUE).poll();
        } else if (!partitionQueue.get(FROM_QUEUE).isEmpty()) {
            token = partitionQueue.get(FROM_QUEUE).poll();
        } else if (!partitionQueue.get(TO_QUEUE).isEmpty()) {
            token = partitionQueue.get(TO_QUEUE).poll();
        }

        return token;
    }

    private Queue<String> initialiseArgQueue(ArrayList<String> argsList) {
        Queue<String> argsQueue = new LinkedList<String>();
        for (String arg : argsList) {
            argsQueue.offer(arg);
        }
        return argsQueue;
    }

    private void initialisePartitionQueue() {
        partitionQueue = new ArrayList<Queue<String>>();
        for (int i = 0; i < NUM_QUEUE; i++) {
            partitionQueue.add(new LinkedList<String>());
        }
    }

    private void initialiseHasTaskComponentArray() {
        hasTaskComponentArray = new boolean[Task.NUM_BOOLEAN_TASK_COMPONENT];
    }

    private void initialiseTaskComponentArray() {
        taskComponentArray = new String[Task.NUM_TASK_COMPONENT];
        taskComponentArray[Task.DESCRIPTION] = " ";
        taskComponentArray[Task.START_DATE] = TaskDate.DEFAULT_DATE;
        taskComponentArray[Task.END_DATE] = taskComponentArray[Task.START_DATE];
        taskComponentArray[Task.START_TIME] = TaskTime.DEFAULT_START_TIME;
        taskComponentArray[Task.END_TIME] = TaskTime.DEFAULT_END_TIME;
        taskComponentArray[Task.TASK_PRIORITY] = TaskPriority.DEFAULT_PRIORITY;
        taskComponentArray[Task.RECURRING_TYPE] = RecurringType.DEFAULT_RECURRING;
        taskComponentArray[Task.TAG] = "";
    }

    private ArrayList<String> tokenizeArguments(String args) {
        ArrayList<String> argsList = new ArrayList<String>();
        StringTokenizer st = new StringTokenizer(args, " ");
        while (st.hasMoreTokens()) {
            argsList.add(st.nextToken());
        }
        return argsList;
    }
```
###### \java\seedu\taskell\model\task\Description.java
``` java
/**
 * Represents a Task's description in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDescription(String)}
 */
public class Description {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Task description should be spaces or alphanumeric characters";

    public String description;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        description = description.trim();
        if (!isValidDescription(description)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.description = description;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return !test.isEmpty();
    }

    public void setDescription(String description){
        this.description = description;
    }
    
    @Override
    public String toString() {
        return description;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.description.equals(((Description) other).description)); // state check
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\EventTask.java
``` java
/**
 * Represents an Event task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class EventTask extends Task {
    public static final String MESSAGE_EVENT_CONSTRAINTS = "Start date and time must be before end date and time"
            + "\nAll date and time should not before current time";
    
    private String[] taskComponentArray;
    private boolean[] hasTaskComponentArray;
    
    public EventTask(String[] taskComponentArray, boolean[] hasTaskComponentArray, UniqueTagList tags) throws IllegalValueException {
        
        this.taskComponentArray = taskComponentArray;
        this.hasTaskComponentArray = hasTaskComponentArray;
        this.tags = tags;
        
        setTaskComponents();
    }
    
    private void setTaskComponents() throws IllegalValueException {
        TaskDate eventStartDate = new TaskDate(this.taskComponentArray[START_DATE]);
        TaskTime eventEndTime = new TaskTime(this.taskComponentArray[END_TIME]);
        RecurringType eventRecurringType = new RecurringType(this.taskComponentArray[RECURRING_TYPE]);
        
        TaskTime eventStartTime = setStartTime(eventStartDate);
        eventStartDate = adjustStartDate(eventStartDate, eventStartTime);
        
        TaskDate eventEndDate = setEndDate(eventStartDate, eventStartTime, eventEndTime);
        
        if (!isValidEventDuration(eventStartDate, eventEndDate, eventStartTime, eventEndTime)) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINTS);
        }
        
        if(!isValidRecurringEvent(eventStartDate, eventEndDate, eventRecurringType)){
            throw new IllegalValueException(RecurringType.MESSAGE_INVALID_RECURRING_DURATION);
        }
        
        this.description = new Description(taskComponentArray[DESCRIPTION]);
        this.taskType = EVENT_TASK;
        this.startDate = eventStartDate;
        this.endDate = eventEndDate;
        this.startTime = eventStartTime;
        this.endTime = eventEndTime;
        this.taskPriority = new TaskPriority(taskComponentArray[TASK_PRIORITY]);
        this.recurringType = eventRecurringType;
        this.taskStatus = new TaskStatus(TaskStatus.INCOMPLETE);
    }
    
    private TaskDate adjustStartDate(TaskDate eventStartDate, TaskTime eventStartTime) throws IllegalValueException {
        if (TaskDate.isValidFullDate(taskComponentArray[START_DATE]) 
                && eventStartDate.isBefore(TaskDate.getTodayDate())) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINTS);
        } else if (TaskDate.isValidMonthAndYear(taskComponentArray[START_DATE])
                && eventStartDate.isBefore(TaskDate.getTodayDate())) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINTS);
        }
        
        if (!hasTaskComponentArray[START_DATE_COMPONENT] && eventStartTime.isBefore(TaskTime.getTimeNow())) {
            eventStartDate = eventStartDate.getNextDay();
        }
        
        return eventStartDate;
    }
    
    private TaskTime setStartTime(TaskDate eventStartDate) throws IllegalValueException {
        if (eventStartDate.equals(TaskDate.getTodayDate()) && !hasTaskComponentArray[Task.START_TIME_COMPONENT]) {
            return TaskTime.getTimeNow();
        } else {
            return new TaskTime(taskComponentArray[Task.START_TIME]);
        }
    }
    
    private TaskDate setEndDate(TaskDate eventStartDate, TaskTime eventStartTime, TaskTime eventEndTime) throws IllegalValueException {
        
        initialiseEndDate(eventStartDate);
        
        TaskDate eventEndDate = adjustEndDateDependingOnDateForm(eventStartDate, eventStartTime, eventEndTime);
        
        eventEndDate = adjustEndDateDependingOnEndTime(eventStartDate, eventEndDate, eventStartTime, eventEndTime);
        
        return eventEndDate;
    }
    
    /**
     * Adjust end date when start and end date is the same but end time is before start time.
     * Bring end date to the next day
     */
    private TaskDate adjustEndDateDependingOnEndTime(TaskDate eventStartDate, TaskDate eventEndDate, TaskTime eventStartTime, 
            TaskTime eventEndTime) throws IllegalValueException {
        if (!hasTaskComponentArray[END_DATE_COMPONENT] && eventStartDate.equals(eventEndDate) && eventEndTime.isBefore(eventStartTime)) {
            eventEndDate = eventEndDate.getNextDay();
        }
        return eventEndDate;
    }
    
    /**
     * Adjustment is made to end date to make sure end date is never before start date
     */
    private TaskDate adjustEndDateDependingOnDateForm(TaskDate eventStartDate, TaskTime eventStartTime, 
            TaskTime eventEndTime) throws IllegalValueException {
        
        TaskDate eventEndDate = new TaskDate(taskComponentArray[Task.END_DATE]);
        String userInputEndDate = taskComponentArray[END_DATE];
        
        if (TaskDate.isValidFullDate(userInputEndDate) && eventEndDate.isBefore(eventStartDate)
                || TaskDate.isValidMonthAndYear(userInputEndDate) && eventEndDate.isBefore(eventStartDate)) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINTS);
        } else if (TaskDate.isValidDayOfWeek(userInputEndDate)) {
            eventEndDate = determineDayInWeekGivenName(eventStartDate, eventEndDate);
        } else if (TaskDate.isValidMonth(userInputEndDate)) {
            eventEndDate = determineEndDateGivenMonth(eventStartDate, eventEndDate);
        } else if (TaskDate.isValidDayAndMonth(userInputEndDate)) {
            eventEndDate = determineEndDateGivenMonth(eventStartDate, eventEndDate);
        } 
        
        return eventEndDate;
    }
    
    private void initialiseEndDate(TaskDate eventStartDate) {
        if (!hasTaskComponentArray[Task.END_DATE_COMPONENT]) {
            taskComponentArray[Task.END_DATE] = eventStartDate.toString();
        }
    }
    
    /**
     * Determines end date in the week with respect to start date
     */
    private TaskDate determineDayInWeekGivenName(TaskDate eventStartDate, TaskDate eventEndDate) {
        
        if (!eventEndDate.isAfter(eventStartDate) && hasTaskComponentArray[END_DATE_COMPONENT]) {
            try {
                eventEndDate = eventEndDate.getNextWeek();
            } catch (IllegalValueException e) {
                return null;
            }
        }
        return eventEndDate;
    }
    
    /**
     * Determine end date in the year with respect to start date
     */
    private TaskDate determineEndDateGivenMonth(TaskDate eventStartDate, TaskDate eventEndDate) {
        if (!eventEndDate.isAfter(eventStartDate)&& hasTaskComponentArray[END_DATE_COMPONENT]) {
            try {
                int yearOfExpectedEndDate = eventStartDate.getNextYear().getYearInt();
                int dayInEndDate = eventEndDate.getDayInt();
                int monthInEndDate = eventEndDate.getMonthInt();
                eventEndDate = new TaskDate(TaskDate.convertToStandardFormat(dayInEndDate, monthInEndDate, yearOfExpectedEndDate));
            } catch (IllegalValueException e) {
                return null;
            }
        }
        return eventEndDate;
    }
    
```
###### \java\seedu\taskell\model\task\EventTask.java
``` java
    private boolean isValidEventDuration(TaskDate startDate, TaskDate endDate, TaskTime startTime, TaskTime endTime) {
        TaskDate today = TaskDate.getTodayDate();
        TaskTime currentTime = TaskTime.getTimeNow();
        
        if (startDate.isBefore(today) || endDate.isBefore(today)) {
            return false;
        } else if (startDate.isAfter(endDate)) {
            return false;
        } else if (startDate.equals(today) && startTime.isBefore(currentTime)) { 
            return false;
        } else if (endDate.equals(today) && endTime.isBefore(currentTime)){
            return false;
        } else {
            return true;
        }
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }
}
```
###### \java\seedu\taskell\model\task\FloatingTask.java
``` java
/**
 * Represents a Floating Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class FloatingTask extends Task {
    
    public static final String RECURRING_TYPE_NOT_ALLOWED = "Floating task cannot be recurring";
    public static final String EDIT_FLOATING_NOT_ALLOWED = "Floating task does not have date and time.";
    
    
    public FloatingTask(String[] taskComponentArray, boolean[] hasTaskComponentArray, UniqueTagList tags) throws IllegalValueException {

        this(new Description(taskComponentArray[DESCRIPTION]),
                new TaskDate(TaskDate.DEFAULT_DATE),
                new TaskDate(TaskDate.DEFAULT_DATE),
                new TaskTime(TaskTime.DEFAULT_START_TIME),
                new TaskTime(TaskTime.DEFAULT_END_TIME),
                new TaskPriority(taskComponentArray[TASK_PRIORITY]),
                new RecurringType(taskComponentArray[RECURRING_TYPE]),
                new TaskStatus(TaskStatus.INCOMPLETE),
                tags);
        
        if (hasTaskComponentArray[Task.RECURRING_COMPONENT]) {
            throw new IllegalValueException(FloatingTask.RECURRING_TYPE_NOT_ALLOWED);
        }
    }
    
    public FloatingTask(Description description, TaskDate startDate, 
            TaskDate endDate, TaskTime startTime, TaskTime endTime, TaskPriority taskPriority, 
            RecurringType recurringType, TaskStatus taskStatus, UniqueTagList tags) {
        
        super(description, FLOATING_TASK, 
                startDate, endDate, 
                startTime, endTime, 
                taskPriority, recurringType, 
                taskStatus, tags);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

}
```
###### \java\seedu\taskell\model\task\TaskDate.java
``` java
/**
 * Represents a Task's taskDate in the task manager.
 * Guarantees: is valid as declared in {@link #isValidDate(String)}
 */
public class TaskDate {
    public static final int JANUARY = 1;
    public static final int FEBRUARY = 2;
    public static final int MARCH = 3;
    public static final int APRIL = 4;
    public static final int MAY = 5;
    public static final int JUNE = 6;
    public static final int JULY = 7;
    public static final int AUGUST = 8;
    public static final int SEPTEMBER = 9;
    public static final int OCTOBER = 10;
    public static final int NOVEMBER = 11;
    public static final int DECEMBER = 12;

    public static final int MONDAY = 1;
    public static final int TUESDAY = 2;
    public static final int WEDNESDAY = 3;
    public static final int THURSDAY = 4;
    public static final int FRIDAY = 5;
    public static final int SATURDAY = 6;
    public static final int SUNDAY = 7;

    public static final int NUM_DAYS_PER_DAY = 1;
    public static final int NUM_DAYS_IN_A_WEEK = 7;
    public static final int NUM_DAYS_IN_A_MONTH = 30;
    public static final int NUM_MONTHS_IN_A_YEAR = 12;
    
    public static final int INVALID_DAY_OF_WEEK = -1;
    public static final int INVALID_DAY_OF_MONTH = -1;
    public static final int INVALID_MONTH = -1;
    public static final int INVALID_YEAR = -1;

    public static final int FIRST_DAY_OF_THE_MONTH = 1;
    
    public static final String DATE_DELIMITER = " .-/";
    
    public static final String DEFAULT_DATE = getDefaultDate();

    public static final Pattern TASK_DATE_ARGS_FORMAT = Pattern
            .compile("(?<day>(3[0-1]|2[0-9]|1[0-9]|[1-9]))" + "(-)(?<month>(1[0-2]|[1-9]))" + "(-)(?<year>([0-9]{4}))");
    private static final DateTimeFormatter standardFormat = DateTimeFormatter.ofPattern("d-MM-yyyy");
    SimpleDateFormat sdf = new SimpleDateFormat("d M yyyy");
    
    public static final String MESSAGE_TASK_DATE_CONSTRAINTS =
            "Task dates should be separated by '-' or '.' or '/'"
            + "\nSpelling of month should be in full or 3-letters"
            + "\nYear should only be 4-digits";

    public String taskDate;
    
    /**
     * Initialize the different fields given taskDate in the format of 
     * DAY-MONTH-YEAR, separated by DATE_DELIMITER
     * @throws IllegalValueException 
     */
    public TaskDate(String dateToAdd) throws IllegalValueException {
        if (isValidFullDate(dateToAdd)) {
            setDateGivenFullDate(dateToAdd);
        } else if (isValidDayAndMonth(dateToAdd)) {
            setDateGivenDayMonth(dateToAdd);
        } else if (isValidMonthAndYear(dateToAdd)) {
            setDateGivenMonthYear(dateToAdd);
        } else if (isValidMonth(dateToAdd)) {
            setDateGivenMonth(dateToAdd);
        } else if (isValidDayOfWeek(dateToAdd)) {
            setDateGivenDayNameOfWeek(dateToAdd);
        } else if (isValidToday(dateToAdd)) {
            setDateGivenToday(dateToAdd);
        } else if (isValidTomorrow(dateToAdd)) {
            setDateGivenTomorrow(dateToAdd);
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    /**
     * Extract the different fields from taskDate having the format of
     * DAY-MONTH-YEAR, separated by DATE_DELIMITER
     * @throws DateTimeException
     * @throws IllegalValueException 
     */
    private void setDateGivenFullDate(String dateToConvert) throws DateTimeException, IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = Integer.valueOf(tokenArr[0]);
        String monthStr = tokenArr[1];
        int month;
        try {
            month = Integer.valueOf(tokenArr[1]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(tokenArr[2]);

        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    private void setDateGivenDayMonth(String dateToConvert) throws IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = Integer.valueOf(tokenArr[0]);
        String monthStr = tokenArr[1];
        int month;
        try {
            month = Integer.valueOf(tokenArr[1]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(getThisYear());
        
        TaskDate date = new TaskDate(convertToStandardFormat(day, month, year));
        if (!date.isAfter(getTodayDate())) {
            year++;
        }

        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }

    private void setDateGivenMonthYear(String dateToConvert) throws IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = FIRST_DAY_OF_THE_MONTH;
        String monthStr = tokenArr[0];
        int month;
        try {
            month = Integer.valueOf(tokenArr[0]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(tokenArr[1]);
        
        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    private void setDateGivenMonth(String monthToConvert) throws IllegalValueException {
        TaskDate date = determineDayGivenMonth(monthToConvert);
        setDate(date.getLocalDate().getDayOfMonth(), 
                date.getLocalDate().getMonthValue(),
                date.getLocalDate().getYear());
    }
    
    private TaskDate determineDayGivenMonth(String monthToConvert) throws IllegalValueException {
        int day = FIRST_DAY_OF_THE_MONTH;
        int month = convertMonthIntoInteger(monthToConvert);
        int year = Integer.valueOf(getThisYear());
        
        TaskDate date = new TaskDate(convertToStandardFormat(day, month, year));
        if (!date.isAfter(getTodayDate())) {
            year++;
        }
        
        return new TaskDate(convertToStandardFormat(day, month, year));
    }
    
    private void setDateGivenDayNameOfWeek(String dayName) {
        TaskDate finalDate = determineDayInWeekGivenName(dayName);
        setDate(finalDate.getLocalDate().getDayOfMonth(), 
                finalDate.getLocalDate().getMonthValue(), 
                finalDate.getLocalDate().getYear());
    }
    
    public static TaskDate determineDayInWeekGivenName(String dayName) {
        int day = convertDayOfWeekIntoInteger(dayName);
        LocalDate today = LocalDate.now();
        String todayDayNameInWeek = today.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
        int todayDayInWeek = convertDayOfWeekIntoInteger(todayDayNameInWeek);
        
        int daysToAdd = day - todayDayInWeek;
        if (daysToAdd <= 0) {
            daysToAdd += NUM_DAYS_IN_A_WEEK;
        }
        
        LocalDate finalDate = today.plusDays(daysToAdd);
        String newDateString = convertToStandardFormat(finalDate.getDayOfMonth(), 
                finalDate.getMonthValue(), finalDate.getYear());
        
        try {
            return new TaskDate(newDateString);
        } catch (IllegalValueException e) {
            return null;
        }
    }
    
    private void setDateGivenToday(String taskDate) {
        LocalDate today = LocalDate.now();
        setDate(today.getDayOfMonth(), today.getMonthValue(), today.getYear());
    }
    
    private void setDateGivenTomorrow(String taskDate) {
        LocalDate today = LocalDate.now();
        LocalDate tomorrow = today.plusDays(1);
        setDate(tomorrow.getDayOfMonth(), tomorrow.getMonthValue(), tomorrow.getYear());
    }
    
    /**
     * Extract the different fields of a given valid taskDate
     * @throws DateTimeException
     */
    public void setDate(int day, int month, int year) {
        this.taskDate = convertToStandardFormat(day, month, year);
    }
    
    /**
     * Convert this TaskDate to the format of
     * DAY_MONTH-YEAR
     */
    public static String convertToStandardFormat(int day, int month, int year) {
        return day + "-" + month + "-" + year;
    }

    /**
     * Returns true if a given string is a valid task taskDate.
     */
    public static boolean isValidDate(String dateToValidate) {
        if (dateToValidate == null || dateToValidate.isEmpty()) {
            return false;
        }
        
        return isValidFullDate(dateToValidate) || isValidMonthAndYear(dateToValidate)
                || isValidDayAndMonth(dateToValidate) || isValidMonth(dateToValidate) || isValidToday(dateToValidate)
                || isValidTomorrow(dateToValidate) || isValidDayOfWeek(dateToValidate);
    }

    /**
     * Returns true if given string is the same as a name of the week
     */
    public static boolean isValidDayOfWeek(String dateToValidate) {
        return !(convertDayOfWeekIntoInteger(dateToValidate) == INVALID_DAY_OF_WEEK);
    }

    public static boolean isValidMonthAndYear(String dateToValidate) {
        return (isValidFormat(dateToValidate, "MMM yyyy") || isValidFormat(dateToValidate, "MMM-yyyy")
                || isValidFormat(dateToValidate, "MMM.yyyy")
                || isValidFormat(dateToValidate, "MMM/yyyy"));
    }

    public static boolean isValidDayAndMonth(String dateToValidate) {
        return (isValidFormat(dateToValidate, "d MMM") || isValidFormat(dateToValidate, "d-MMM")
                || isValidFormat(dateToValidate, "d.MMM")
                || isValidFormat(dateToValidate, "d/MMM"));
    }

    public static boolean isValidFullDate(String dateToValidate) {
        return (isValidFormat(dateToValidate, "d M yyyy") || isValidFormat(dateToValidate, "d MMM yyyy")
                || isValidFormat(dateToValidate, "d-M-yyyy") || isValidFormat(dateToValidate, "d-MMM-yyyy")
                || isValidFormat(dateToValidate, "d.M.yyyy") || isValidFormat(dateToValidate, "d.MMM.yyyy")
                || isValidFormat(dateToValidate, "d.M-yyyy") || isValidFormat(dateToValidate, "d.MMM-yyyy")
                || isValidFormat(dateToValidate, "d-M.yyyy") || isValidFormat(dateToValidate, "d-MMM.yyyy")
                || isValidFormat(dateToValidate, "d/M/yyyy") || isValidFormat(dateToValidate, "d/MMM/yyyy")
                || isValidFormat(dateToValidate, "d-M/yyyy") || isValidFormat(dateToValidate, "d-MMM/yyyy")
                || isValidFormat(dateToValidate, "d/M-yyyy") || isValidFormat(dateToValidate, "d/MMM-yyyy")
                || isValidFormat(dateToValidate, "d.M/yyyy") || isValidFormat(dateToValidate, "d.MMM/yyyy")
                || isValidFormat(dateToValidate, "d/M.yyyy") || isValidFormat(dateToValidate, "d/MMM.yyyy"));
    }

    /**
     * Returns true if a given string has a valid format supported by SimpleDateFormat.
     */
    public static boolean isValidFormat(String dateToValidate, String acceptedFormat) {
        if (dateToValidate == null) {
            return false;
        }

        SimpleDateFormat sdf = new SimpleDateFormat(acceptedFormat);
        sdf.setLenient(false);

        try {
            // if not valid, it will throw ParseException
            Date taskDate = sdf.parse(dateToValidate);
        } catch (ParseException e) {
            return false;
        }

        return true;
    }

    /**
     * Returns true if given string contains a word that suggest today
     */
    public static boolean isValidToday(String dateToValidate) {
        assert (dateToValidate != null);
        String dateToValidateIgnoreCase = dateToValidate.toLowerCase();
        
        switch (dateToValidateIgnoreCase) {
        case "today":
            // Fallthrough
        case "tdy":
            return true;
        default:
            return false;
        }
    }

    /**
     * Returns true if given string contains a word that suggest tomorrow
     */
    public static boolean isValidTomorrow(String dateToValidate) {
        assert (dateToValidate != null);
        String dateToValidateIgnoreCase = dateToValidate.toLowerCase();
        
        switch (dateToValidateIgnoreCase) {
        case "tomorrow":
            // Fallthrough
        case "tmr":
            return true;
        default:
            return false;
        }
    }

    /**
     * Returns true if the given string has the same name as a month in the year
     */
    public static boolean isValidMonth(String month) {
        return (convertMonthIntoInteger(month) != INVALID_MONTH);
    }

    /**
     * Returns an integer representing the day in a week
     */
    private static int convertDayOfWeekIntoInteger(String day) {
        assert (day != null);
        String dayIgnoreCase = day.toLowerCase();

        switch (dayIgnoreCase) {
        case "mon":
            // Fallthrough
        case "monday":
            return MONDAY;
        case "tue":
            // Fallthrough
        case "tues":
            // Fallthrough
        case "tuesday":
            return TUESDAY;
        case "wed":
            // Fallthrough
        case "wednesday":
            return WEDNESDAY;
        case "thu":
            // Fallthrough
        case "thur":
            // Fallthrough
        case "thurs":
            // Fallthrough
        case "thursday":
            return THURSDAY;
        case "fri":
            // Fallthrough
        case "friday":
            return FRIDAY;
        case "sat":
            // Fallthrough
        case "saturday":
            return SATURDAY;
        case "sun":
            // Fallthrough
        case "sunday":
            return SUNDAY;
        default:
            return INVALID_DAY_OF_WEEK;
        }
    }

    /**
     * Returns an integer representing the month of a year.
     */
    private static int convertMonthIntoInteger(String month) {
        assert (month!= null);
        String monthIgnoreCase = month;
        if (Character.isLetter(month.charAt(0))) {
            monthIgnoreCase = month.toLowerCase();
        }

        switch (monthIgnoreCase) {
        case "jan":
            // Fallthrough
        case "january":
            return JANUARY;
        case "feb":
            // Fallthrough
        case "february":
            return FEBRUARY;
        case "mar":
            // Fallthrough
        case "march":
            return MARCH;
        case "apr":
            // Fallthrough
        case "april":
            return APRIL;
        case "may":
            return MAY;
        case "jun":
            // Fallthrough
        case "june":
            return JUNE;
        case "jul":
            // Fallthrough
        case "july":
            return JULY;
        case "aug":
            // Fallthrough
        case "august":
            return AUGUST;
        case "sep":
            // Fallthrough
        case "sept":
            // Fallthrough
        case "september":
            return SEPTEMBER;
        case "oct":
            // Fallthrough
        case "october":
            return OCTOBER;
        case "nov":
            // Fallthrough
        case "november":
            return NOVEMBER;
        case "dec":
            // Fallthrough
        case "december":
            return DECEMBER;
        default:
            return INVALID_MONTH;
        }
    }

    /**
     * Get today's taskDate in the format of
     * DAY-MONTH-YEAR
     */
    public static TaskDate getTodayDate() {
        try {
            return new TaskDate(LocalDate.now().format(standardFormat));
        } catch (IllegalValueException e) {
            return null;
        }
    }

    /**
     * Get tomorrow's taskDate in the format of
     * DAY-MONTH-YEAR
     */
    public static TaskDate getTomorrowDate() {
        try {
            return new TaskDate(LocalDate.now().plusDays(1).format(standardFormat));
        } catch (IllegalValueException e) {
            return null;
        }
    }
    
    public TaskDate getNextDay() throws IllegalValueException {
        try {
            LocalDate localDate = this.getLocalDate();
            LocalDate nextDay = localDate.plusDays(1);
            return new TaskDate(nextDay.format(standardFormat));
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public TaskDate getNextWeek() throws IllegalValueException {
        try {
            LocalDate localDate = this.getLocalDate();
            LocalDate nextWeek = localDate.plusWeeks(1);
            return new TaskDate(nextWeek.format(standardFormat));
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
```
###### \java\seedu\taskell\model\task\TaskDate.java
``` java
    public TaskDate getNextYear() throws IllegalValueException {
        try {
            LocalDate localDate = this.getLocalDate();
            LocalDate nextMonth = localDate.plusYears(1);
            return new TaskDate(nextMonth.format(standardFormat));
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    /**
     * Returns a string representing the integer value of this year
     */
    public static String getThisYear() {
        return LocalDate.now().getYear() + "";
    }
    
    public String getDay() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("day");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public int getDayInt() {
        try {
            return Integer.valueOf(getDay());
        } catch (NumberFormatException | IllegalValueException e) {
            return INVALID_DAY_OF_MONTH;
        }
    }
    
    public String getMonth() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("month");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public int getMonthInt() {
        try {
            return Integer.valueOf(getMonth());
        } catch (NumberFormatException | IllegalValueException e) {
            return INVALID_MONTH;
        }
    }
    
    public String getYear() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("year");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public int getYearInt() {
        try {
            return Integer.valueOf(getYear());
        } catch (NumberFormatException | IllegalValueException e) {
            return INVALID_YEAR;
        }
    }
    
    public String getDayNameInWeek() {
        LocalDate localDate = this.getLocalDate();
        String dayNameInWeek = localDate.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
        return dayNameInWeek;
    }
    
    public String getMonthName() {
        LocalDate localDate = this.getLocalDate();
        String month = localDate.getMonth().getDisplayName(TextStyle.FULL, Locale.US);
        return month;
    }
    
    public String getDisplayDate() {
        return getDayNameInWeek() + ", " + getDayInt() + " " + getMonthName() + " " + getYearInt();
    }
    
    public LocalDate getLocalDate() {
        return LocalDate.of(getYearInt(), getMonthInt(), getDayInt());
    }

    public static String getDefaultDate() {
        int day = LocalDate.now().getDayOfMonth();
        int month = LocalDate.now().getMonthValue();
        int year = LocalDate.now().getYear();
        return convertToStandardFormat(day, month, year);
    }
    
    /**
     * Returns true if the given date is before this date
     */
    public boolean isBefore(TaskDate date) {
        try {
            LocalDate thisDate = this.getLocalDate();
            LocalDate dateToComapare = date.getLocalDate();
            return thisDate.isBefore(dateToComapare);
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Returns true if the given date is after this date
     */
    public boolean isAfter(TaskDate date) {
        try {
            LocalDate thisDate = this.getLocalDate();
            LocalDate dateToComapare = date.getLocalDate();
            return thisDate.isAfter(dateToComapare);
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Calculates the number of days from the first date to the second date
     */
    public static long between(TaskDate first, TaskDate second) {
        return ChronoUnit.DAYS.between(first.getLocalDate(), second.getLocalDate());
    }
    
    public LocalDateTime toLocalDateTime(TaskTime time) {
        return LocalDateTime.of(this.getLocalDate(), time.getLocalTime());
    }
    
    /**
     * Returns a string with the format of
     * DAY-MONTH-YEAR
     */
    @Override
    public String toString() {
        return taskDate;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.taskDate.equals(((TaskDate)other).taskDate));
    }

    @Override
    public int hashCode() {
        return taskDate.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\TaskPriority.java
``` java
/**
 * Represents a Task's priority in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class TaskPriority {
    
    public static final String MESSAGE_TASK_PRIORITY_CONSTRAINTS = "Task priority should range from 0-3"
            + "\nThere should not be more than 1 priority level for a task";
    public static final String TASK_PRIORITY_VALIDATION_REGEX = ".+";
    
    public static final String PREFIX = "p/";
    
    public static final String NO_PRIORITY = "0";
    public static final String LOW_PRIORITY = "1";
    public static final String MEDIUM_PRIORITY = "2";
    public static final String HIGH_PRIORITY = "3";
    
    public static final String DEFAULT_PRIORITY = NO_PRIORITY;
    
    public static final String LOW_PRIORITY_BACKGROUND = "-fx-background-color: #4CAF50";
    public static final String MEDIUM_PRIORITY_BACKGROUND = "-fx-background-color: #FFEB3B";
    public static final String HIGH_PRIORITY_BACKGROUND = "-fx-background-color: #F44336";

    public final String taskPriority;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public TaskPriority(String priority) throws IllegalValueException {
        assert priority != null;
        if (!isValidPriority(priority)) {
            throw new IllegalValueException(MESSAGE_TASK_PRIORITY_CONSTRAINTS);
        }
        this.taskPriority = priority;
    }

    /**
     * Returns true if a given string is a valid task taskPriority.
     */
    public static boolean isValidPriority(String priority) {
        return priority.equals(NO_PRIORITY)
                || priority.equals(LOW_PRIORITY) 
                || priority.equals(MEDIUM_PRIORITY)
                || priority.equals(HIGH_PRIORITY);
    }

    @Override
    public String toString() {
        return taskPriority;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskPriority // instanceof handles nulls
                && this.taskPriority.equals(((TaskPriority) other).taskPriority)); // state check
    }

    @Override
    public int hashCode() {
        return taskPriority.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\TaskTime.java
``` java
/**
 * Represents a Task's taskTime in the task manager.
 */
public class TaskTime {

    public static final String ZERO_MINUTE = "00";
    public static final String NOON = "12:00PM";
    public static final String MIDNIGHT = "12:00AM";

    public static final String AM = "AM";
    public static final String PM = "PM";

    public static final int TIME_OFFSET = 12;

    public static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("h:mma");

    public static final String DEFAULT_START_TIME = MIDNIGHT;
    public static final String DEFAULT_END_TIME = "11:59PM";

    public static final Pattern TASK_TIME_ARGS_FORMAT = Pattern.compile(
            "(?<hour>(1[0-2]|[1-9]))" + "(.|-|:)(?<minute>([0-5][0-9]))" + "(?<antePost>(am|pm|AM|PM|Am|Pm|aM|pM))");
    public static final Pattern TASK_TIME_HOUR_ONLY_FORMAT = Pattern
            .compile("(?<hour>(1[0-2]|[1-9]))" + "(?<antePost>(am|pm|AM|PM|Am|Pm|aM|pM))");
    final static String FULL_TIME_REGEX = "^(1[0-2]|[1-9])(.|-|:)([0-5][0-9])(am|pm|AM|PM|Am|Pm|aM|pM)$";
    final static String HOUR_ONLY_TIME_REGEX = "^(1[0-2]|[1-9])(am|pm|AM|PM|Am|Pm|aM|pM)$";

    public static final String MESSAGE_TASK_TIME_CONSTRAINTS = "Time should be in 12hour clock format."
            + "\nHour and Minute are separated by '.' or ':'" + "\nEg. 9.30am or 12:50pm";

    public String taskTime; // Standard format

    public TaskTime(String time) throws IllegalValueException {
        if (isValidTime(time)) {
            setTime(time);
        } else {
            throw new IllegalValueException(MESSAGE_TASK_TIME_CONSTRAINTS);
        }
    }

    /**
     * Returns true if given string is a valid 12-hour time in the real world
     */
    public static boolean isValidTime(String time) {
        assert time != null;
        if (time.isEmpty()) {
            return false;
        }

        return (time.matches(HOUR_ONLY_TIME_REGEX) || time.matches(FULL_TIME_REGEX) || isValidNoon(time)
                || isValidMidnight(time));
    }

    /*
     * private static boolean isValidNow(String time) { time =
     * time.toLowerCase(); return "now".equals(time); }
     */

    private static boolean isValidNoon(String time) {
        time = time.toLowerCase();
        switch (time) {
        case "afternoon":
            // Fallthrough
        case "noon":
            // Fallthrough
        case "12noon":
            // Fallthrough
        case "12-noon":
            return true;
        default:
            return false;
        }
    }

    private static boolean isValidMidnight(String time) {
        time = time.toLowerCase();
        switch (time) {
        case "midnight":
            // Fallthrough
        case "mid-night":
            // Fallthrough
        case "12midnight":
            // Fallthrough
        case "12-midnight":
            // Fallthrough
        case "12mid-night":
            // Fallthrough
        case "12-mid-night":
            // Fallthrough
            return true;
        default:
            return false;
        }
    }

    /**
     * Checks if this time is before the specified time
     */
    public boolean isBefore(TaskTime time) {
        LocalTime timeToCompare = time.getLocalTime();
        LocalTime thisTimeLocalTime = this.getLocalTime();
        return thisTimeLocalTime.isBefore(timeToCompare);
    }

    /**
     * Checks if this time is after the specified time
     */
    public boolean isAfter(TaskTime time) {
        LocalTime timeToCompare = time.getLocalTime();
        LocalTime thisTimeLocalTime = this.getLocalTime();
        return thisTimeLocalTime.isAfter(timeToCompare);
    }

    public void setTime(String time) throws IllegalValueException {
        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(time.trim());
        final Matcher matcherHourOnly = TASK_TIME_HOUR_ONLY_FORMAT.matcher(time.trim());
        if (matcherFullArg.matches()) {
            this.taskTime = setTime(matcherFullArg.group("hour"), matcherFullArg.group("minute"),
                    matcherFullArg.group("antePost"));
        } else if (matcherHourOnly.matches()) {
            this.taskTime = setTime(matcherHourOnly.group("hour"), ZERO_MINUTE, matcherHourOnly.group("antePost"));
        } else if (isValidNoon(time)) {
            this.taskTime = NOON;
        } else if (isValidMidnight(time)) {
            this.taskTime = MIDNIGHT;
        } else {
            throw new IllegalValueException(MESSAGE_TASK_TIME_CONSTRAINTS);
        }
    }

    public String setTime(String hour, String minute, String antePost) {
        this.taskTime = hour + ":" + minute + antePost.toUpperCase();
        return taskTime;
    }

    public static TaskTime getTimeNow() {
        LocalTime currTime = LocalTime.now();
        try {
            return new TaskTime(LocalTime.of(currTime.getHour(), currTime.getMinute()).format(dtf));
        } catch (IllegalValueException e) {
            return null;
        }
    }

    public String getHour() {
        assert taskTime != null;

        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("hour");
        }

        return "";
    }

    public String getMinute() {
        assert taskTime != null;

        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("minute");
        }

        return "";
    }

    public String getAntePost() {
        assert taskTime != null;

        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("antePost");
        }

        return "";
    }

    public LocalTime getLocalTime() {
        int timeHour = Integer.valueOf(this.getHour());
        if (this.getAntePost().equals(PM) && (timeHour != TIME_OFFSET)) {
            timeHour += TIME_OFFSET;
        } else if (this.getAntePost().equals(AM) && (timeHour == TIME_OFFSET)) {
            timeHour -= TIME_OFFSET;
        }
        return LocalTime.of(timeHour, Integer.valueOf(this.getMinute()));
    }

    public LocalDateTime toLocalDateTime(TaskDate date) {
        return LocalDateTime.of(date.getLocalDate(), this.getLocalTime());
    }

    @Override
    public String toString() {
        return taskTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                        && this.taskTime.equals(((TaskTime) other).taskTime)); // state
                                                                               // check
    }

    @Override
    public int hashCode() {
        return (taskTime).hashCode();
    }
}
```
###### \java\seedu\taskell\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
        id.setText(displayedIndex + ". ");
        description.setText(task.getDescription().description);
        tags.setText(task.tagsString());
        recurringType.setText(task.getRecurringType().recurringType);
        taskStatus.setText(task.getTaskStatus().taskStatus);
        
        setDateTime();
        setDateTimeVisibility();
        setPriorityPaneColour();
        setBackgroundColour();
    }

    private void setDateTime() {
        startDate.setText(task.getStartDate().getDisplayDate());
        endDate.setText(task.getEndDate().getDisplayDate());
        startTime.setText(task.getStartTime().taskTime);
        endTime.setText(task.getEndTime().taskTime);
    }
    
    private void setDateTimeVisibility() {
        if (task.getTaskType().equals(Task.FLOATING_TASK)) {
            startDate.setVisible(false);
            endDate.setVisible(false);
            startTime.setVisible(false);
            endTime.setVisible(false);
        }
        
        if (task.getRecurringType().recurringType.equals(RecurringType.NO_RECURRING)) {
            recurringType.setVisible(false);
        }
    }
    
    private void setPriorityPaneColour() {
        if (task.getTaskPriority().taskPriority.equals(TaskPriority.HIGH_PRIORITY)) {
            priorityColour.setStyle(TaskPriority.HIGH_PRIORITY_BACKGROUND);
        } else if (task.getTaskPriority().taskPriority.equals(TaskPriority.MEDIUM_PRIORITY)) {
            priorityColour.setStyle(TaskPriority.MEDIUM_PRIORITY_BACKGROUND);
        } else if (task.getTaskPriority().taskPriority.equals(TaskPriority.LOW_PRIORITY)) {
            priorityColour.setStyle(TaskPriority.LOW_PRIORITY_BACKGROUND);
        }
    }
```
